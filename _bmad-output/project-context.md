---
project_name: 'eneos-sales-automation'
user_name: 'Jiraw'
date: '2026-02-10'
sections_completed: ['technology_stack', 'language_specific', 'framework_specific', 'testing', 'code_quality', 'workflow', 'critical_rules']
status: 'complete'
rule_count: 210
optimized_for_llm: true
---

# Project Context for AI Agents

_This file contains critical rules and patterns that AI agents must follow when implementing code in this project. Focus on unobvious details that agents might otherwise miss._

---

## Technology Stack & Versions

**Runtime & Language:**
- Node.js ≥20.0.0 (ES2022 target)
- TypeScript 5.6.3 with strict mode enabled
- ES Modules ONLY - `.js` extension REQUIRED in all imports

**Core Framework:**
- Express.js 4.21.0

**Database (CRITICAL):**
- Supabase PostgreSQL (`@supabase/supabase-js` ^2.95.3) - THIS IS THE DATABASE
- UUID = Primary Key (auto-generated by Supabase)
- Version column for optimistic locking (race condition protection)
- 8 columns in sales_team: id, line_user_id, name, email, phone, role, status, auth_user_id (FK → auth.users)
- 6 tables: leads, dedup_log, sales_team, status_history, campaign_events, campaign_stats
- RLS enabled on all tables — service_role key bypasses RLS
- snake_case columns in DB, camelCase in app — use mapper functions at service boundaries
- Supabase client timeout: 10 seconds via `AbortSignal.timeout()` in global fetch override

**External Integrations:**
- LINE Bot SDK ^9.4.0 - Signature verification MANDATORY
- Google Gemini AI ^0.21.0 - Fallback to defaults on API failure
- Supabase Auth - Admin Dashboard authentication (Email+Password + Google OAuth)
- jsonwebtoken - Backend JWT verification (~0.1ms local verify with SUPABASE_JWT_SECRET)
- @supabase/ssr - Frontend server-side auth for Next.js (cookie-based sessions)
- Brevo Webhooks:
  - `/webhook/brevo` - Automation (no event field) → Create Lead
  - `/webhook/brevo/campaign` - Campaigns (has event field) → Track Stats

**Export Libraries:**
- ExcelJS ^4.4.0 - XLSX generation with styled headers, zebra striping, auto-filter
- json2csv ^6.0.0-alpha.2 - CSV generation (MUST add UTF-8 BOM `\uFEFF` for Thai)
- PDFKit ^0.17.2 - PDF generation with Thai font (NotoSansThai-Regular.ttf)

**Testing (Version-Specific Patterns):**
- Vitest 2.1.2 - Use `vi.hoisted()` for mock hoisting (NOT Jest patterns)
- Supertest 7.2.2 - Required for HTTP integration tests
- Coverage: 75%+ enforced, CI fails on drop

**Developer Tooling:**
- Husky ^9.1.7 + lint-staged - Pre-commit hooks (eslint --fix + tsc --noEmit)
- prom-client ^15.1.3 - Prometheus metrics at `/metrics`
- Sentry ^10.32.1 - Error tracking (optional)

**TypeScript Constraints:**
- strict: true, noUnusedLocals: true, noUnusedParameters: true, noImplicitReturns: true
- Path alias: `@/*` → `src/*` (tsconfig.json)
- Unused variables = BUILD FAILURE

---

## Language-Specific Rules

### ES Modules (CRITICAL)
- ALL imports MUST include `.js` extension: `import { config } from './config/index.js'`
- Module resolution: NodeNext - NO CommonJS patterns
- NO `require()` statements - use `import` only
- Test files ALSO require `.js` extensions

### TypeScript Patterns
- Use `import type` for type-only imports: `import type { Lead } from '../types/index.js'`
- Export types from `src/types/index.ts` - single source of truth
- Admin-specific types in `src/types/admin.types.ts`
- Underscore prefix for unused params: `(_req, res, _next)` - ESLint configured
- Prefer `interface` for object shapes, `type` for unions/aliases

### Logger Usage (Domain-Specific)
- Use `createModuleLogger('moduleName')` for service-specific loggers
- Domain loggers: `webhookLogger`, `campaignLogger`
- NOT generic `logger` unless truly general

### Config Access (MANDATORY)
- ALWAYS use `config` object from `../config/index.js`
- NEVER access `process.env` directly in application code
- Exception: `admin-auth.ts` reads `SUPABASE_JWT_SECRET` from config (middleware init)

### Service Pattern
- Services export **named functions**, NOT classes or wrapper objects
- No more compatibility wrappers — all wrappers removed in Epic 9
- Services are singletons initialized at module load
- Wrap external calls with `withRetry()` from `utils/retry.js`
- Name collision solution: use aliases `import { fn as fnService } from '...'`

### snake_case ↔ camelCase Mapping (CRITICAL)
- Supabase uses snake_case columns, app uses camelCase
- Use `fromSupabaseLead(supabaseRow)` to convert DB → App
- Use `toSupabaseLead(leadData)` to convert App → DB
- Mapper functions live in `src/types/index.ts`
- NEVER mix case styles — always convert at service boundary

### Error Handling
- Custom error classes: `AppError`, `ValidationError`, `RaceConditionError`, `DuplicateLeadError`, `ExternalServiceError`
- Include context: `new AppError('message', statusCode, 'ERROR_CODE')`
- Re-throw `AppError` subclasses, catch generic errors

### Testing Language Patterns (Vitest-Specific)
- Use `vi.fn()` NOT `jest.fn()`
- Use `vi.hoisted()` for mock hoisting
- Use `vi.mock()` NOT `jest.mock()`

### `_testOnly` Export Pattern
- Private functions exposed for testing via `_testOnly` object:
```typescript
export const _testOnly = {
  mapRole,
};
```
- Used in `admin-auth.ts` and similar modules with private state
- Allows testing internal logic without making functions public

---

## Framework-Specific Rules

### Express.js Patterns

**Middleware Order (CRITICAL):**
1. `helmet()` - Security headers
2. `cors()` - CORS configuration
3. `express.json()` - Body parsing (BUT raw for LINE webhook)
4. `requestContext` - Request ID tracking
5. `rateLimiter` - Rate limiting
6. Route handlers
7. `errorHandler` - Centralized error handling (LAST)

**LINE Route Raw Body Isolation (CRITICAL):**
- LINE webhook route uses `express.raw({ type: '*/*' })` for signature verification
- This MUST be mounted BEFORE the global `express.json()` middleware
- If routes are reorganized, signature verification will break silently
- Never move LINE routes below `express.json()` in the middleware chain

**Route Organization:**
- Routes: `src/routes/` - Define endpoints
- Controllers: `src/controllers/` - Request/response ONLY
- Services: `src/services/` - ALL business logic
- Validators: Execute BEFORE controllers via Zod schemas

**Controller Pattern (Thin Controllers):**
```typescript
export async function handleWebhook(req: Request, res: Response, next: NextFunction) {
  try {
    const result = await serviceFunction(req.body);
    res.status(200).json(result);
  } catch (error) {
    next(error);  // ALWAYS pass to centralized handler
  }
}
```

**asyncHandler vs Explicit try/catch:**
- `asyncHandler()` from `middleware/error-handler.ts` wraps controllers in routes
- Controllers wrapped with `asyncHandler` do NOT need their own try/catch — errors auto-forward to error middleware
- Use explicit try/catch ONLY when custom error response is needed (e.g., `exportData` returns formatted validation errors instead of generic middleware response)
- Usage: `router.get('/path', asyncHandler(controllerFn))`

**Route Ordering (CRITICAL):**
- Static routes MUST be defined BEFORE dynamic parameterized routes
- Example: `/sales-team/list` BEFORE `/sales-team/:lineUserId`
- Example: `/campaigns/stats` BEFORE `/campaigns/:id`
```typescript
// WRONG — :id captures "stats" as a parameter
router.get('/campaigns/:id', handler);
router.get('/campaigns/stats', handler);  // NEVER REACHED

// CORRECT — static first
router.get('/campaigns/stats', handler);
router.get('/campaigns/:id', handler);
```

**Admin Controller Helpers:**
- Complex logic extracted to `src/controllers/admin/helpers/`
- Helpers: `sort.helpers.ts`, `time.helpers.ts`, `period.helpers.ts`, `stats.helpers.ts`, `filter.helpers.ts`, `transform.helpers.ts`
- Re-exported via `helpers/index.ts` barrel file
- Controllers stay thin — import helpers for computation

### Admin Auth (Supabase Auth + RBAC)

**Authentication Flow:**
1. Extract Bearer token from `Authorization` header
2. Verify JWT locally with `jsonwebtoken` + `SUPABASE_JWT_SECRET` (~0.1ms)
3. Extract `email`, `sub` (auth_user_id), and `app_metadata.role` from JWT claims
4. Double-check user exists in `sales_team` table via `getUserByEmail()` + `status: 'active'` (defense in depth)
5. Auto-link `auth_user_id` on first login (race-safe with `.is('auth_user_id', null)`)
6. Attach `req.user` with `{ email, role, authUserId, memberId }`

**Identity Link (auth_user_id):**
- `sales_team` table has `auth_user_id UUID UNIQUE REFERENCES auth.users(id)` column
- Auto-linked on first login via atomic conditional update (same pattern as `linkLINEAccount`)
- Migration: `003_add_auth_user_id.sql`

**Admin Invite Flow (ORDERING CRITICAL):**
1. Create `sales_team` record FIRST (email, name, role)
2. THEN invite via `supabase.auth.admin.inviteUserByEmail(email)`
3. NEVER invite before creating sales_team — user may login before record exists

**Role Storage:**
- Role stored in `app_metadata` (NOT `user_metadata` — user can edit user_metadata = privilege escalation)
- Source of truth: `sales_team.role` — `app_metadata` is just a cache in JWT
- Role set via `supabase.auth.admin.inviteUserByEmail(email, { data: { role } })`

**Role-Based Access Control:**
- `admin` role: full access (export, team management, settings, user invite)
- `viewer` role: read-only (dashboard, leads, reports)
- NO `manager` role — simplified to 2 roles only (add later if needed)
- Role mapping: DB `'admin'` → `'admin'`, DB `'sales'` or any → `'viewer'`
- Middleware: `requireAdmin` (admin only), `requireViewer` (admin + viewer)
- Inactive users (`status: 'inactive'`) blocked at auth level with 403

**Login Methods:**
- Email+Password (primary — for clients without Google email)
- Google OAuth (secondary — via Supabase Google provider)
- Self-signup DISABLED — admin invite-only (enterprise security)

**Rate Limiting:**
- Global: 100 requests/60s (configurable via env)
- Export-specific: 10 requests/hour/user (resource intensive)
- Rate limit key: `req.user.email` for authenticated routes

### LINE Bot SDK (CRITICAL PATTERNS)

**1-Second Response Rule:**
```typescript
res.status(200).send('OK');
processLineEvent(req.body).catch(handleError);
```
- LINE retries if no 200 within 1 second
- Failure = duplicate lead processing

**Signature Verification:**
- Use raw body: `express.raw({ type: '*/*' })` for LINE route
- NEVER skip in production (`SKIP_LINE_SIGNATURE_VERIFICATION=false`)

**Flex Messages:**
- Templates in `src/templates/` as JSON files
- Use builder functions, not inline JSON

### Supabase Integration

**Client Setup:**
- Singleton client in `src/lib/supabase.ts`
- Uses `SUPABASE_URL` + `SUPABASE_SERVICE_ROLE_KEY` from config
- Service role key bypasses RLS — use for server-side operations only
- Global fetch override with 10-second `AbortSignal.timeout()`

**Health Check (DO NOT USE RPC):**
- `checkSupabaseHealth()` uses `supabase.from('sales_team').select('id', { count: 'exact', head: true })`
- Do NOT use `rpc('version')` — `public.version()` doesn't exist in Supabase (only `pg_catalog.version()`)
- This was a real bug found and fixed in Epic 9

**Query Patterns:**
- Chainable API: `supabase.from('table').select().eq('col', val).single()`
- Terminal methods: `.single()`, `.maybeSingle()` — resolve the Promise
- Error handling: check `{ data, error }` response pattern

**Race Condition Protection (MANDATORY):**
1. Read current lead with version via `getLeadById(uuid)`
2. Check if `sales_owner_id` already set
3. If claimed → throw `RaceConditionError`
4. If available → update with `.eq('version', currentVersion)` (optimistic lock)

**Deduplication:**
- Supabase upsert with `ignoreDuplicates: true`
- UNIQUE constraint on key column — no Redis/memory cache needed

**Fire-and-Forget Writes:**
- `addStatusHistory()` catches ALL errors internally, never throws
- Used for audit logs that must not block main operations

**Atomic Conditional Updates:**
- Use `.is('column', null)` for race-safe conditional updates (e.g., `linkLINEAccount`)

### Gemini AI Integration

**Graceful Fallback Pattern:**
```typescript
try {
  return await geminiService.analyzeCompany(domain);
} catch (error) {
  logger.warn('Gemini failed, using defaults', { error });
  return { industry: 'ไม่ระบุ', talkingPoint: 'ENEOS มีน้ำมันหล่อลื่นคุณภาพสูง' };
}
```
- NEVER fail the entire request due to AI error
- Always have sensible Thai defaults

**Parallel Enrichment Pattern:**
```typescript
const [aiResult, campaignLookup] = await Promise.all([
  geminiService.analyzeCompany(domain, company).catch(() => defaults),
  leadsService.lookupCampaignId(email).catch(() => null),
]);
```
- AI enrichment + campaign lookup run in parallel
- Each has independent `.catch()` fallback — one failure doesn't block the other

### Background Processing

**Fire-and-Forget Pipeline:**
1. Webhook responds `200 OK` immediately
2. `processLeadAsync()` fires without await
3. Pipeline: AI Enrichment → Save to Supabase → LINE Notification
4. Failed events go to Dead Letter Queue (DLQ)
5. Processing status tracked via `processingStatusService`

**`processingStatusService` is In-Memory Only:**
- Tracks processing state for correlation IDs
- NOT durable — all state lost on server restart
- Do NOT rely on it for persistent tracking or recovery
- DLQ is the durable fallback for failed events

### Validation Pattern (Zod)

**Two validator helpers:**
- `validateQuery()` — throws on failure (used when you want error middleware to handle it)
- `safeValidateQuery()` — returns `{ success, data }` or `{ success: false, errors }` (used for custom error response)
- Schemas live in `src/validators/admin.validators.ts`
- Constants (pagination, sort options, periods) in `src/constants/admin.constants.ts`
- Use `z.coerce.number()` for query param numbers (they arrive as strings)

---

## Testing Rules

### Test File Organization
- Location: `src/__tests__/` directory
- Naming: `*.test.ts` suffix
- Structure mirrors `src/`:
  - `__tests__/services/` → tests for `services/`
  - `__tests__/controllers/` → tests for `controllers/`
  - `__tests__/utils/` → tests for `utils/`
- Shared mocks: `__tests__/mocks/` - REUSE these

### Setup File
- `src/__tests__/setup.ts` loaded before ALL tests
- Configure global mocks here, not in individual tests
- Timeouts: 10 seconds per test, 10 seconds for hooks

### Mock Hoisting Pattern (CRITICAL ORDER)
```typescript
// 1. vi.hoisted() FIRST - creates mock objects
const { mockClient } = vi.hoisted(() => ({
  mockClient: { pushMessage: vi.fn().mockResolvedValue({}) }
}));

// 2. vi.mock() SECOND - uses hoisted mocks
vi.mock('@line/bot-sdk', () => ({
  Client: vi.fn(() => mockClient)
}));

// 3. imports THIRD - after mocks are set up
import { sendNotification } from '../../services/line.service.js';
```

### Transitive Import Mocking (GOTCHA)
- If your test target transitively imports `createModuleLogger`, the test WILL fail unless mocked
- Rule: **Always check what your test target imports — mock transitive dependencies too**
- Common case: sales performance trend test needs `createModuleLogger` mock
```typescript
vi.mock('../../utils/logger.js', () => ({
  createModuleLogger: vi.fn(() => ({
    info: vi.fn(), warn: vi.fn(), error: vi.fn(), debug: vi.fn(),
  })),
}));
```

### Namespace vs Named Import Mocking
- **Namespace import** (`import * as service from '...'`): entire module mocked, no partial override
- **Named import** (`import { fn } from '...'`): individual functions can be mocked
- `line.controller.ts` uses namespace import — entire `leadsService` must be mocked
- New controllers should prefer named imports for easier partial mocking

### Mock Key Matches Original Export Name (NOT Alias)
- When controller uses alias: `import { getCampaignEvents as getCampaignEventsService }`
- The mock key must match the **original export name**:
```typescript
// CORRECT — matches the service's export name
vi.mock('../../services/campaign-stats.service.js', () => ({
  getCampaignEvents: vi.fn(),  // original name, not alias
}));
```

### Test Structure Pattern
```typescript
describe('ServiceName', () => {
  beforeEach(() => {
    vi.clearAllMocks();  // Reset BEFORE each test
  });

  describe('functionName', () => {
    it('should do expected behavior', async () => {
      // Arrange - setup test data
      // Act - call function
      // Assert - verify result
    });
  });
});
```

### `clearAllMocks` vs `resetAllMocks` vs `restoreAllMocks` (KNOW THE DIFFERENCE)
| Method | Behavior | Use? |
|--------|----------|------|
| `vi.clearAllMocks()` | Clears call history + results, **keeps implementation** | **YES — our standard** |
| `vi.resetAllMocks()` | Clears everything AND removes mock implementation | **NO — breaks chain mocks** |
| `vi.restoreAllMocks()` | Reverts to original implementation | **NO — breaks module mocks** |

Rule: **Always use `vi.clearAllMocks()` in `beforeEach`. Never use `resetAllMocks` or `restoreAllMocks` unless you explicitly understand the consequences.**

### External Service Mocking Strategy
| Service | Mock Target | Pattern |
|---------|-------------|---------|
| Supabase | `../../lib/supabase.js` | Chainable mock with `vi.hoisted()` — see `src/__tests__/mocks/supabase.mock.ts` |
| LINE Bot | `@line/bot-sdk` Client | Standard mock |
| Gemini AI | `@google/generative-ai` | Standard mock |
| Redis | `ioredis` | Standard mock |
| jsonwebtoken | `jsonwebtoken` | Mock `jwt.verify()` return value |

### Supabase Chainable Mock Pattern (CRITICAL)
```typescript
const { mockSupabase, mockChain } = vi.hoisted(() => {
  const mockChain = {
    select: vi.fn().mockReturnThis(),
    insert: vi.fn().mockReturnThis(),
    update: vi.fn().mockReturnThis(),
    upsert: vi.fn().mockReturnThis(),  // Required for dedup tests
    eq: vi.fn().mockReturnThis(),
    is: vi.fn().mockReturnThis(),
    in: vi.fn().mockReturnThis(),
    order: vi.fn().mockReturnThis(),
    single: vi.fn().mockResolvedValue({ data: null, error: null }),
    maybeSingle: vi.fn().mockResolvedValue({ data: null, error: null }),
  };
  const mockSupabase = { from: vi.fn().mockReturnValue(mockChain) };
  return { mockSupabase, mockChain };
});
vi.mock('../../lib/supabase.js', () => ({ supabase: mockSupabase }));
```
- Use `createMockSupabaseClient()` from `src/__tests__/mocks/supabase.mock.ts` for full mock
- DON'T use `mockResolvedValueOnce` on chain methods — use `mockImplementation` instead

### Complete Mock Chain Reset (CRITICAL)
```typescript
beforeEach(() => {
  vi.clearAllMocks();
  // Reset chain methods
  Object.values(mockChain).forEach(fn => {
    if (typeof fn.mockReturnThis === 'function') fn.mockReturnThis();
  });
  // Reset terminal methods to defaults (prevents leaking between tests)
  mockChain.single.mockResolvedValue({ data: null, error: null });
  mockChain.maybeSingle.mockResolvedValue({ data: null, error: null });
});
```
Without resetting terminal methods, a test that sets `single.mockResolvedValue({ data: someObj })` leaks into the next test.

### `_testOnly` Export Testing
- Modules like `admin-auth.ts` expose private helpers via `_testOnly` for unit testing
- Example: `_testOnly.mapRole('admin', 'sales')` tests role mapping without going through the full middleware
- No singleton reset needed post-Supabase Auth migration (no stateful clients)

### asyncHandler Error Path Testing
- Controllers wrapped with `asyncHandler` forward errors to error middleware
- Do NOT test that the controller calls `next(error)` directly
- Instead, test the HTTP response from the error middleware:
```typescript
// CORRECT — test the HTTP output
const res = await request(app).get('/api/admin/leads');
expect(res.status).toBe(401);
expect(res.body.error.code).toBe('UNAUTHORIZED');

// WRONG — testing internal next() call
expect(next).toHaveBeenCalledWith(expect.any(AppError));
```

### Fire-and-Forget Test Timing (CRITICAL)
- `processLeadAsync()` returns `void` immediately — you CANNOT verify side effects
- To test the pipeline, call `processLeadInBackground()` directly (the async version)
- NEVER test `processLeadAsync()` for side effects — it's the fire-and-forget wrapper
```typescript
// CORRECT — await the async function directly
await processLeadInBackground(payload, correlationId);
expect(leadsService.addLead).toHaveBeenCalled();

// WRONG — fire-and-forget returns immediately, assertions race
processLeadAsync(payload, correlationId);
expect(leadsService.addLead).toHaveBeenCalled();  // FLAKY
```

### Test Isolation Rules
- Each test MUST be independent
- No shared state between tests
- Tests can run in any order
- NEVER make real API calls

### Coverage & Quality Gate
- Minimum: 75% overall (CI enforced)
- All existing tests must pass — no exceptions
- No test removals without justification
- Coverage must not drop below threshold
- No `.skip` in main branch
- Test count (~1432+) is informational, not a hard gate

### Known Flaky Tests
- `background-processing.integration.test.ts`: Known flaky (hook timeout)
- Passes in isolation but may fail in full suite due to async fire-and-forget timing
- Do NOT waste time debugging intermittent failures on this file

### Integration Test Pattern
```typescript
import request from 'supertest';
import app from '../app.js';

it('should handle webhook', async () => {
  const response = await request(app)
    .post('/webhook/brevo')
    .set('X-Brevo-Signature', 'valid-sig')
    .send(payload);

  expect(response.status).toBe(200);
});
```

---

## Code Quality & Style Rules

### ESLint Configuration
- Config: `eslint.config.mjs` (flat config format — NOT legacy `.eslintrc`)
- Parser: `@typescript-eslint/parser`
- Extends: ESLint recommended + TypeScript ESLint recommended

### Enforced Rules
| Rule | Setting | Reason |
|------|---------|--------|
| `no-console` | warn | Use logger instead |
| `eqeqeq` | always | Use === not == |
| `curly` | all | Always use braces |
| `no-var` | error | Use const/let |
| `prefer-const` | error | Immutability default |
| `@typescript-eslint/no-explicit-any` | warn | Type safety |
| `@typescript-eslint/no-unused-vars` | error | Clean code (underscore prefix to ignore) |
| `@typescript-eslint/no-namespace` | off | Allowed for Express augmentation |
| `@typescript-eslint/no-require-imports` | off | Allowed (some dynamic imports) |

### Security Rules (MANDATORY)
- `no-eval: error` - Never use eval()
- `no-implied-eval: error` - No setTimeout with strings
- `no-new-func: error` - No Function constructor

### Unused Variables Pattern
```typescript
// Prefix with underscore to indicate intentionally unused
app.use((_req, res, _next) => { });  // OK
app.use((req, res, next) => { });    // Error if unused
```
- Pattern applies to args, vars, and caught errors: `argsIgnorePattern: '^_'`, `varsIgnorePattern: '^_'`, `caughtErrorsIgnorePattern: '^_'`

### Test Files — Relaxed Rules
In `*.test.ts` and `__tests__/**/*.ts`:
- `no-console: off`
- `@typescript-eslint/no-explicit-any: off`
- `@typescript-eslint/no-non-null-assertion: off`
- `@typescript-eslint/no-unused-vars: off`

### File Naming Conventions
| Type | Pattern | Example |
|------|---------|---------|
| Source files | `kebab-case.ts` | `leads.service.ts` |
| Test files | `kebab-case.test.ts` | `leads.service.test.ts` |
| Types | `kebab-case.ts` | `admin.types.ts` |
| Constants | `kebab-case.ts` | `admin.constants.ts` |
| Helpers | `kebab-case.helpers.ts` | `sort.helpers.ts` |
| Migrations | `NNN_description.sql` | `001_initial_schema.sql` |

### Code Organization
- Single Responsibility: One service = One domain
- Constants in `src/constants/`
- Validators in `src/validators/`
- Admin controllers in `src/controllers/admin/`
- Admin helpers in `src/controllers/admin/helpers/` with `index.ts` barrel

### Dependency Direction (CRITICAL — NO CIRCULAR IMPORTS)
```
Controllers → Services → Utils
     ↓            ↓         ↓
  Middleware → Services → Utils
     ↓
   Types ← (imported by ALL layers — leaf dependency)
```
- **Services MUST NOT import from controllers**
- **Utils MUST NOT import from services or controllers**
- **Middleware CAN import from services** (e.g., `admin-auth.ts` imports `getUserByEmail`)
- **Types (`src/types/`) are imported by all layers** — they are leaf dependencies
- Circular dependencies in ES Modules cause silent `undefined` imports at runtime

### `src/lib/` Convention for Client Singletons
- Third-party client wrappers live in `src/lib/`, NOT `src/services/`
- Currently: `src/lib/supabase.ts` (Supabase client singleton)
- Services consume clients from `lib/`
- If adding a new external client (e.g., S3, SendGrid), create it in `src/lib/`
- Rule: **`lib/` = client wrappers, `services/` = business logic**

### Barrel File Discipline
- **USE barrels** (`index.ts`): `helpers/`, `types/`, `constants/`
- **DO NOT use barrels**: `services/`, `controllers/`, `middleware/`
- Services and controllers are imported by direct path:
```typescript
// CORRECT — direct import
import { addLead } from '../services/leads.service.js';

// WRONG — no barrel for services
import { addLead } from '../services/index.js';
```

### Constants Pattern
```typescript
// Use `as const` for immutable constant objects
export const PAGINATION = {
  DEFAULT_PAGE: 1,
  DEFAULT_LIMIT: 20,
  MAX_LIMIT: 100,
} as const;

// Use `as const` on arrays — REQUIRED for z.enum() type inference
export const VALID_PERIODS = ['today', 'week', 'month'] as const;
export type PeriodType = typeof VALID_PERIODS[number];
```
- Without `as const` on arrays, Zod `z.enum()` infers `string` instead of the union type
- Both array and object constants MUST use `as const`

### Dynamic Imports for Heavy Libraries (MANDATORY)
```typescript
// CORRECT — dynamic import, loaded only when export route is hit
const { default: ExcelJS } = await import('exceljs');
const { parse } = await import('json2csv');
const PDFDocument = (await import('pdfkit')).default;

// WRONG — loads on every server start even if never used
import ExcelJS from 'exceljs';
```
- Applies to: ExcelJS, json2csv, PDFKit, and any future heavy optional libraries
- These are only needed in export routes — no reason to load at startup
- Keeps server startup fast and memory lean

### Standard API Response Shapes (MANDATORY)
```typescript
// Standard success response
{
  success: true,
  data: { ... }
}

// Standard error response
{
  success: false,
  error: {
    code: 'ERROR_CODE',      // Machine-readable UPPER_SNAKE_CASE
    message: 'Human message', // Thai or English
    details?: [...]           // Optional validation details array
  }
}
```
- ALL admin API endpoints MUST follow this shape
- Frontend error handling depends on `error.code` for routing
- Do NOT return flat `{ error: 'string' }` — must be nested structure

### Thai Error Messages in Validators
- Zod validation error messages are written in **Thai** for admin API endpoints
- Frontend displays these directly to Thai-speaking users
```typescript
// CORRECT — Thai for user-facing admin API
z.string().min(1, 'Campaign ID ต้องไม่ว่าง')
z.enum(['leads', 'all'], { errorMap: () => ({ message: 'type ต้องเป็น leads หรือ all' }) })

// WRONG — English in admin API validators
z.string().min(1, 'Campaign ID is required')
```

### Documentation Standards
- JSDoc for public service functions
- Section comments with `// ===` dividers
- Thai comments acceptable (bilingual project)
- No redundant comments for obvious code

### Feature Flags
```typescript
// CORRECT — use config
if (config.features.aiEnrichment) { }

// WRONG — never comment out code
// if (true) { doAiStuff(); }
```

### Pre-Commit Hooks (Husky + lint-staged)
- Triggers on `git commit` automatically
- Runs on staged `src/**/*.ts` files only:
  1. `eslint --fix` — auto-fix lint errors
  2. `tsc --noEmit` — type check
- If either fails, commit is blocked
- Do NOT bypass with `--no-verify` unless explicitly instructed

---

## Development Workflow Rules

### Scripts
| Command | Description |
|---------|-------------|
| `npm run dev` | Start dev server (tsx watch) |
| `npm run build` | Compile TypeScript to dist/ + copy Thai font |
| `npm run typecheck` | Type check without emit |
| `npm run lint` | Run ESLint |
| `npm run lint:fix` | Fix ESLint errors |
| `npm test` | Run all tests (Vitest) |
| `npm run test:coverage` | Generate coverage report |
| `npm run test:ui` | Open Vitest UI |
| `npm run test:load` | Run k6 load tests (health + API) |
| `npm run benchmark` | Run background processing benchmark |

### Branch & PR Convention (BMAD Flow)
```
Create Branch → Amelia (Dev) → Open PR → Rex (Code Review) → Merge
                                              ↓ FAIL
                                         Amelia Fix → Push → Rex Again
```

**Branch Naming:**
- Feature: `feat/story-{epic}-{number}` (e.g., `feat/story-6-5`)
- Bugfix: `fix/{short-description}` (e.g., `fix/race-condition-sheets`)
- Hotfix: `hotfix/{short-description}` (e.g., `hotfix/line-signature`)

**Commit Message Convention:**
```
feat: description (Story X-Y)
fix: description
refactor: description
test: description
docs: description
```
- Use conventional commit prefixes: `feat`, `fix`, `refactor`, `test`, `docs`, `chore`
- Include `(Story X-Y)` suffix for story-linked changes — enables traceability
- Keep first line under 72 characters

**PR Rules:**
- NEVER push directly to `main` — must go through PR
- PR must pass CI (quality + test + burn-in) before merge
- CI pipeline must be GREEN before requesting review — Rex rejects red CI immediately
- Rex APPROVED = ready to merge
- No human review required — Rex is the quality gate

### Story Implementation Rules (CRITICAL)

**Story File is Single Source of Truth:**
- Story files in `_bmad-output/` dictate tasks, subtasks, and acceptance criteria
- Implement ONLY what's mapped to a specific task/subtask — no more, no less
- If story says 5 tasks, do 5 tasks — no scope creep
- When story requirements conflict with `project-context.md`, story takes precedence

**Story Completion Definition:**
A story is NOT complete when code is written. All of these must be true:
1. All tasks/subtasks in story file marked done
2. All acceptance criteria verified
3. All tests pass (no `.skip`)
4. Coverage ≥75% (no drops)
5. Rex code review APPROVED
6. PR merged to main

**Sprint Status Tracking:**
- Active sprint status: `_bmad-output/implementation-artifacts/sprint-status.yaml`
- Update story status in this file after completion
- PM uses this for visibility — forgetting to update causes tracking gaps

### Pre-Commit Checklist (Self-Check Before PR)
1. `npm run typecheck` - No type errors
2. `npm run lint` - No lint errors
3. `npm test` - All tests pass
4. Coverage ≥75% (no drops)
5. No `console.log` (use logger)
6. No `.skip` on tests
7. No `any` without justification
8. No dead code, no commented-out code
9. Security: no OWASP Top 10 violations
10. `project-context.md` rules followed
11. Story acceptance criteria all met

### Environment Variables

**Precedence (highest to lowest):**
1. System environment variables (override everything)
2. `.env` file values (loaded by `dotenv` at startup)
3. Zod defaults in `config/index.ts`

**Rules:**
- `.env` for local development — NEVER commit to git
- `.env.example` as template
- `config/index.ts` with Zod validation is the canonical source
- Missing required vars = server fails to start (Zod throws)
- Feature flags have sensible defaults (all `true` in production)

**Adding New Environment Variables Checklist:**
When adding a new env var, you MUST update ALL THREE:
1. `src/config/index.ts` — Add to Zod schema with type and default
2. `.env.example` — Add with description comment
3. Relevant docs (CLAUDE.md, deployment docs)

### Build Process
- `npm run build` compiles TypeScript to `dist/`
- Build also copies `NotoSansThai-Regular.ttf` font to `dist/assets/fonts/`
- PDF export looks for font in both `dist/` and `src/` paths (dev vs prod)
- Docker build MUST preserve the font copy step — missing font = Thai PDF export renders garbled text (silent fallback to Helvetica)

### Deployment Targets
- Railway, Render, Docker, Google Cloud Run
- Health check: `/health`
- Readiness: `/ready`
- Liveness: `/live`

**Health Check Contract:**
- `/health` is used by deployment platforms for health probing
- Currently checks: Supabase (required), Gemini (optional), LINE (optional)
- When adding a new external dependency, consider whether it should be included in health check
- Critical dependencies (database) = health degrades if down
- Optional dependencies (AI, notifications) = health stays healthy, service reports degraded

### Supabase Migrations
- Migration files: `supabase/migrations/NNN_description.sql`
- Push method: `npx supabase db push` (project linked to remote)
- Current migrations:
  - `001_initial_schema.sql` — 6 tables, indexes, RLS, triggers
  - `002_harden_rls_policies.sql` — deny-all for anon on all tables
  - `003_add_auth_user_id.sql` — auth_user_id FK in sales_team → auth.users
- Supabase CLI: v2.76.6

---

## Critical Don't-Miss Rules

### Database Anti-Patterns (Supabase)
- NEVER pass user input directly to `.eq()`, `.ilike()` without sanitization (PostgREST injection)
- NEVER skip version check on updates — use optimistic locking via `version` column
- NEVER use `mockResolvedValueOnce` on Supabase chainable methods — use `mockImplementation`
- NEVER mix camelCase/snake_case — use mapper functions (`toSupabaseLead()`, `fromSupabaseLead()`)
- NEVER let `addStatusHistory()` throw — it's fire-and-forget by design
- NEVER escape `%` and `_` yourself in `.ilike()` — use sanitization utility
- NEVER use `rpc('version')` for health check — `public.version()` doesn't exist in Supabase

### Security Anti-Patterns
- NEVER skip LINE signature verification in production
- NEVER log sensitive data (tokens, passwords, API keys)
- NEVER commit `.env` files
- NEVER disable rate limiting in production
- NEVER trust user input without Zod validation
- NEVER expose service_role key to client-side code — server-side only
- NEVER store role in `user_metadata` — user can edit it (privilege escalation)
- NEVER use `supabase.auth.getUser()` for every request in Backend — use `jsonwebtoken` local verify
- NEVER store tokens in `localStorage` — httpOnly cookie only (XSS prevention)
- NEVER invite Supabase Auth user before creating `sales_team` record
- NEVER use `SERVICE_ROLE_KEY` in Frontend — leaked key = full DB access

### Performance Anti-Patterns
- NEVER block event loop with sync operations
- NEVER make API calls without timeout/retry
- NEVER skip circuit breaker for external services
- NEVER respond to LINE webhook after 1 second
- NEVER use top-level static imports for heavy optional libraries (ExcelJS, PDFKit, json2csv)

### Edge Cases to Handle

**LINE Webhook:**
- Empty events array → Return 200 OK anyway
- Duplicate events (LINE retries) → Use deduplication service
- Invalid signature → Reject immediately with 401
- Postback for already-claimed lead → Reply with "already taken" message
- Legacy `row_id` postback → UUID-based `lead_id` only (legacy not supported)

**Supabase:**
- Version mismatch on update → Throw `RaceConditionError`
- UNIQUE constraint violation (code `23505`) → Return `{ duplicate: true }`, not error
- Connection failure → Health check reports degraded status
- Empty query result → Return `null` or empty array, not error
- FK cascade delete → `status_history` rows deleted when lead deleted

**Gemini AI:**
- API timeout → Use Thai fallback defaults
- Invalid response format → Parse safely, use defaults
- Rate limiting → Retry with exponential backoff
- Complete failure → NEVER block the entire request

**Admin Auth (Supabase Auth):**
- Missing `SUPABASE_JWT_SECRET` → all admin requests return 401
- Invalid/expired JWT → 401 with `INVALID_TOKEN` code
- User not in `sales_team` table → 403 (defense in depth — JWT valid but no record)
- Inactive user in DB → 403 with `ACCOUNT_INACTIVE`
- Non-invited user attempts login → Supabase rejects (self-signup disabled)
- Auto-link `auth_user_id` fails (race condition) → silently skip, no error thrown
- `app_metadata.role` missing → default to `'viewer'`

**Export:**
- CSV without BOM → Thai text garbled in Excel
- PDF without Thai font → Silent fallback to Helvetica (no Thai rendering)
- Export > 10,000 rows → Truncated to `EXPORT.MAX_ROWS`
- PDF > 100 rows → Truncated to `EXPORT.PDF_MAX_PREVIEW_ROWS` with "more rows" footer

### Required Utilities (DON'T REINVENT)
```typescript
import { formatPhone } from '../utils/phone-formatter.js';
import { extractDomain } from '../utils/email-parser.js';
import { formatDateForSheets } from '../utils/date-formatter.js';
import { withRetry } from '../utils/retry.js';
import { createModuleLogger } from '../utils/logger.js';
import { generateUUID } from '../utils/uuid.js';
```

### Thai Language Defaults
When external services fail, use these defaults:
```typescript
{
  industry: 'ไม่ระบุ',
  businessType: 'B2B',
  talkingPoint: 'ENEOS มีน้ำมันหล่อลื่นคุณภาพสูงสำหรับอุตสาหกรรม'
}
```

### Quality Gates (PR Requirements)
- All tests pass (no exceptions)
- Coverage ≥75% (no drops)
- `npm run typecheck` passes
- `npm run lint` passes
- No `.skip` on tests
- No `console.log` (use logger)
- CI pipeline green before review request

---

## Export Patterns

### UTF-8 BOM for Thai CSV Files (CRITICAL)

When exporting CSV files with Thai characters, Excel requires a **Byte Order Mark (BOM)** to display correctly.

**Problem:**
```
Without BOM: à¸šà¸£à¸´à¸©à¸±à¸—  (garbled Thai text in Excel)
With BOM:    บริษัท ทดสอบ จำกัด  (correct display)
```

**Solution Pattern:**
```typescript
const { parse } = await import('json2csv');
const csv = parse(dataToExport);
const csvWithBOM = '\uFEFF' + csv;  // ← Add BOM prefix
res.setHeader('Content-Type', 'text/csv; charset=utf-8');
res.setHeader('Content-Disposition', 'attachment; filename="export.csv"');
res.send(csvWithBOM);
```

**Key Points:**
- `\uFEFF` is the UTF-8 BOM character (U+FEFF)
- Must be the FIRST character in the file
- Required for Excel Thai compatibility on Windows
- Google Sheets and Numbers handle UTF-8 without BOM, but BOM doesn't hurt
- `json2csv` library handles escaping (commas, quotes, newlines) automatically

**When to Use:**
- CSV exports containing Thai text
- Any CSV that users may open in Excel
- NOT needed for JSON, XLSX (ExcelJS handles it), or PDF exports

---

## Usage Guidelines

**For AI Agents:**
- Read this file before implementing any code
- Follow ALL rules exactly as documented
- When in doubt, prefer the more restrictive option
- Update this file if new patterns emerge

**For Humans:**
- Keep this file lean and focused on agent needs
- Update when technology stack changes
- Review quarterly for outdated rules
- Remove rules that become obvious over time

---

*Last Updated: 2026-02-11 (Supabase Auth architecture added — Google OAuth → Supabase Auth migration, jsonwebtoken, @supabase/ssr, auth_user_id FK)*
